\documentclass[14pt]{article}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amsfonts}

\newcommand{\F}{\mathcal{F}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\eps}{\varepsilon}
\newcommand{\D}{\Diamond}
\newcommand{\uD}{\underline{\Diamond}}
\newcommand{\UD}{\overline{\Diamond}}
\begin{document}

\section{Correctness}

\subsection{Boring formalism}

A program is a function $p:\text{Loc}\to\text{Op}$, where $\mathbf{1} \in \text{Loc}$ is singled out as the initial program counter. An execution thread $t\in\mathcal{T}_p$ is given by a machine state $s\in\mathcal{S}$ and a program counter $l\in\text{Loc}_p$ denoted respectively $s_t$ and $l_t$.
The semantic of the machine executing $p$ is the data of a relation $\sigma$ over $\mathcal{T}_p$. The trace semantic of $p$ is defined as the set of $\sigma$-chains rooted in $(\bot,\mathbf{1})$.

Given an abstraction of the machine state $\alpha_S : \mathcal{S}\to\overline{\mathcal{S}}$, the soundness of an abstract semantic $\overline{\sigma}$ is given by :
\[ t \xrightarrow{\sigma} t'  \implies \alpha(t) \xrightarrow{\overline{\sigma}} \alpha(t') \]

In our case, transitions are given by the meaning of operations. This means that $\sigma$ is subject to the following restriction :
\[ t \xrightarrow{\sigma} t' \iff s_{t'} = \text{sem}_{p(l_t)}(s_t) ~\text{and}~ l_{t'} \in \text{br}_{p(l_t)}(s_t)\]
where for each $\text{op} \in \text{Op}$ we have $\text{sem}_{\text{op}} : \mathcal{S}\to\mathcal{S}$ and $\text{br}_{\text{op}} : \mathcal{S} \to 2^\text{Loc}$.

The concrete julia machine being deterministic we always have $|\text{br}_{\text{op}}(s)|=1$.

In that particular case, a sound abstraction of the machine can be defined as an abstract semantic $\overline{\text{sem}}$ for each operation such that :
\[ s' = \text{sem}_{\text{op}}(s) \implies \alpha_S(s') \leq \overline{\text{sem}}_{\text{op}}(\alpha_S(s)) \]
The soundness of $\overline{\text{sem}}$ and $\overline{\text{br}}$ can then be summarized as
\[\left\{\begin{array}{ll}

\alpha_S \circ \text{sem}_{\text{op}} \leq \overline{\text{sem}}_{\text{op}} \circ \alpha_S \\
 \text{br}_{\text{op}} \subseteq \overline{\text{br}}_{\text{op}} \circ \alpha_S

\end{array}\right.\]



\subsection{Implementation scheme}

Given a program and abstraction mapping for the machine state we want to compute some information about the trace semantic of the program. In the most general case, the abstract trace semantic is given by the image of $(\bot,\mathbf{1})$ under the transitive closure of $\overline{\sigma}$. It is of course expressible as a least-fixed-point :
\[ \text{lfp}_{\{(\bot,\mathbf{1})\}}\lambda X. X\cup\left(X\xrightarrow{\overline{\sigma}}\right)\]

Under the finite-chain assumption for $\overline{\mathcal{S}}$, which we can always take for granted given suitable widening operator, the fixed point is reachable in a finite number of steps : it is computable.

This formulation however does not map to an efficient fixed point algorithm. In practice only a small part of the full trace is of interest for the client of the analysis.

\subsection{State for immutable value analysis}

\subsection{State for alias analysis}

A concrete alias state is given by a mapping from finite string of symbols to values $\eps:\mathbf{N}\to\mathbf{V}$, and an aliasing (equivalence) relationship on names $\D \subseteq \mathbf{N}^2$ such that they are compatible, in the sense that $\eps$ lifts as $\tilde{\eps} : \mathbf{N}/\D \to \mathbf{V}$.

An abstract approximation for such an alias state is the data of an upper and lower bound for $\D$ with the correctness of the analysis given by $\uD\leq\D\leq\UD$. In alias analysis terminology, $\uD$ and $\UD$ are called respectively the must-alias and may-alias relationships. Note that if $\uD\leq\D$ the equivalence-closure of $\uD$ is a correct and more precise lower bound. Hence, we can always assume $\uD$ to be an equivalence relationship.

\paragraph{Impl} Only keep short fixed-size strings of field indices (say a byte/half a byte per field). More precise AA information is given by type information. Maybe introduce limited DFA capabilities (probably non nested and only in last position) : $f_1.f_2.(\dots).(f'_1+\dots+f'_n)^*$. The lower bound $\uD$ being an eqv we can use the good old $O(\alpha^{-1}(n))$ amortized union find structure. Still need to think if taking the eqv closure of $\UD$ is too lossy OR if not taking it is too expensive.


\subsection{State classification}

There are two dimensions upon which we may wish to exercise the precision-efficienty tradeoff : control flow and temporality. 


\subsection{Remaining Qs}

Temporary state keys classification in decreasing precision order :
\begin{itemize}
\item Per trace bounded cyclic strong update [age]
\item Per trace pc-sensitive strong update [var type]
\item Per trace weak update [?]
\item Per func weak update [SA var type]
\end{itemize}
Can the cylic strong update trick fit in those or does it need a separate value type ? Can the distinction be dynamically inferred (e.g. SA/SASU var) ?

Needed information from the state to the scheduler : has converged ?
Most general case : assume saved state before each op.
Optimizations :
if a particular state key is pc-insensitive (thus weak) we only need to remember a boolean flag (increased) (...not generic enough)

Is there a generic way to handle optimal state memoization ?
Can it be done dynamically ? Or does it require static knowledge of use/def r/w info for each insn (or conservative approximation thereof) ?

\end{document}
