\documentclass[14pt]{article}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amsfonts}

\newcommand{\F}{\mathcal{F}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\eps}{\varepsilon}
\newcommand{\D}{\Diamond}
\newcommand{\uD}{\underline{\Diamond}}
\newcommand{\UD}{\overline{\Diamond}}
\begin{document}

\section{Correctness}

\subsection{Boring formalism}

A program is a function $p:\text{Loc}\to\text{Op}$, where $\mathbf{1} \in \text{Loc}$ is singled out as the initial program counter. An execution thread $t\in\mathcal{T}_p$ is given by a machine state $s\in\mathcal{S}$ and a program counter $l\in\text{Loc}_p$ denoted respectively $s_t$ and $l_t$.
The semantic of the machine executing $p$ is the data of a relation $\sigma$ over $\mathcal{T}_p$. The trace semantic of $p$ is defined as the set of $\sigma$-chains rooted in $(\bot,\mathbf{1})$.

Given an abstraction of the machine state $\alpha_S : \mathcal{S}\to\overline{\mathcal{S}}$, the soundness of an abstract semantic $\overline{\sigma}$ is given by :
\[ t \xrightarrow{\sigma} t'  \implies \alpha(t) \xrightarrow{\overline{\sigma}} \alpha(t') \]

In our case, transitions are given by the meaning of operations. This means that $\sigma$ is subject to the following restriction :
\[ t \xrightarrow{\sigma} t' \iff s_{t'} = \text{sem}_{p(l_t)}(s_t) ~\text{and}~ l_{t'} \in \text{br}_{p(l_t)}(s_t)\]
where for each $\text{op} \in \text{Op}$ we have $\text{sem}_{\text{op}} : \mathcal{S}\to\mathcal{S}$ and $\text{br}_{\text{op}} : \mathcal{S} \to 2^\text{Loc}$.

The concrete julia machine being deterministic we always have $|\text{br}_{\text{op}}(s)|=1$.

In that particular case, a sound abstraction of the machine can be defined as an abstract semantic $\overline{\text{sem}}$ for each operation such that :
\[ s' = \text{sem}_{\text{op}}(s) \implies \alpha_S(s') \leq \overline{\text{sem}}_{\text{op}}(\alpha_S(s)) \]
i.e.
\[ \alpha_S \circ \text{sem}_{\text{op}} \leq \overline{\text{sem}}_{\text{op}} \circ \alpha_S \]
and
\[ \text{br}_{\text{op}} \subseteq \overline{\text{br}}_{\text{op}} \circ \alpha_S \]

\subsection{Implementation scheme}

Given a program and abstraction mapping for the machine state we want to compute some information about the trace semantic of the program. In the most general case, the abstract trace semantic is given by the image of $(\bot,\mathbf{1})$ under the transitive closure of $\overline{\sigma}$. It is of course expressible as a least-fixed-point :
\[ \text{lfp}_{\{(\bot,\mathbf{1})\}}\lambda X. X\cup\left(X\xrightarrow{\overline{\sigma}}\right)\]

Under the finite-chain assumption for $\overline{\mathcal{S}}$, which we can always take for granted given suitable widening operator, the fixed point is reachable in a finite number of steps : it is computable.

This formulation however does not map to an efficient fixed point algorithm. In practice only a small part of the full trace is of interest for the client of the analysis.

\subsection{State for immutable value analysis}

%A concrete s

\subsection{State for alias analysis}

A concrete alias state is given by a mapping from finite string of symbols to values $\eps:\mathbf{N}\to\mathbf{V}$, and an aliasing (equivalence) relationship on names $\D \subseteq \mathbf{N}^2$ such that they are compatible, in the sense that $\eps$ lifts as $\tilde{\eps} : \mathbf{N}/\D \to \mathbf{V}$.

An abstract approximation for such an alias state is the data of an upper and lower bound for $\D$ such that the correctness of the analysis is given by $\uD\leq\D\leq\UD$. In alias analysis terminology, $\uD$ and $\UD$ are called respectively the must-alias and may-alias relationships. Note that if $\uD\leq\D$ the equivalence-closure of $\uD$ is a correct and more precise lower bound. Hence, we can always assume $\uD$ to be an equivalence relationship.

\subsection{Remaining Qs}

Temporary state keys classification. Can the cylic strong update trick fit in those or does it need a separate value type ?.
\begin{itemize}
\item Per trace strong update
\item Per trace weak update
\item Per func weak update
\end{itemize}

Is there a generic way to handle optimal state memoization ?



%\paragraph{(Maybe)} We can always restrict ourselves to $\mathcal{S}$ being a mapping from a (possibly infinite) fixed set of names $\mathbf{N}$ to a set of values $\mathbf{V}$ such that every operation is of the following form :


\end{document}
